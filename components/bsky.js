import { z } from "zod";
import { readFileSync, writeFileSync } from "fs";
import { join } from "path";

const BSKY_PUBLIC = "https://public.api.bsky.app";
const BSKY_CATALOG_PATH = join(process.env.HOME || "/tmp", "moltbook-mcp", "bsky-agents.json");

const BSKY_STRONG_BOT_RE = [
  /\bi am a bot\b/i, /\bi('m| am) an? (ai |artificial |autonomous |llm )?agent\b/i,
  /\bautomated account\b/i, /\bautonomous ai\b/i,
  /\bbuilt (with|on|using) (claude|gpt|llama|gemini|openai|anthropic)/i,
  /\bpowered by (claude|gpt|llama|gemini|openai|anthropic)/i,
  /\bbot account\b/i, /\bnot a human\b/i, /\bfully autonomous\b/i,
  /\bai-powered bot\b/i, /\bautomated posts?\b/i,
];
const BSKY_WEAK_BOT_RE = [/\bbot\b/i, /\bagent\b/i, /\bautomated\b/i, /\bai-powered\b/i, /\bllm\b/i];
const BSKY_HANDLE_RE = [/bot[s]?\./i, /\.bot$/i, /agent\./i, /ai-?\w*\./i];
const BSKY_HUMAN_RE = [/\bphd\b/i, /\bprofessor\b/i, /\bresearcher\b/i, /\bstudent\b/i, /\bfounder\b/i, /\bceo\b/i, /\bdeveloper\b/i, /\bengineer\b/i, /\bi (work|research|study|build|create)\b/i];
const BSKY_AI_RE = [/\bautonomous ai\b/i, /\b(claude|gpt|llama|gemini|openai|anthropic)\b/i, /\bllm\b/i, /\bai.?agent\b/i];
const BSKY_POST_RE = [/\bi am a bot\b/i, /\bi am an ai\b/i, /\bgenerated by\b/i, /\bautonomous(ly)?\b/i, /\bmy (creator|developer|operator)\b/i, /\bsession \d+/i, /\b(claude|gpt|llm)\b/i];
const BSKY_SEARCH_QUERIES = ["bot autonomous AI", "I am a bot", "I am an AI agent", "automated account", "autonomous agent bluesky", "claude agent", "GPT bot", "LLM bot bluesky"];

function bskyScoreProfile(actor) {
  const desc = actor.description || "";
  const handle = actor.handle || "";
  const name = (actor.displayName || "").toLowerCase();
  let score = 0; let aiScore = 0; const signals = [];
  for (const re of BSKY_STRONG_BOT_RE) { if (re.test(desc)) { score += 30; signals.push(`strong:${re.source.slice(0,20)}`); } }
  for (const re of BSKY_WEAK_BOT_RE) { if (re.test(desc)) { score += 5; signals.push(`weak:${re.source.slice(0,15)}`); } }
  for (const re of BSKY_HANDLE_RE) { if (re.test(handle)) { score += 15; signals.push(`handle`); } }
  if (/bot/i.test(name)) { score += 10; signals.push("name_bot"); }
  if (/ai.*agent|agent.*ai/i.test(name)) { score += 15; signals.push("name_ai_agent"); }
  for (const re of BSKY_HUMAN_RE) { if (re.test(desc)) { score -= 15; signals.push(`human`); } }
  for (const re of BSKY_AI_RE) { if (re.test(desc) || re.test(actor.displayName || "")) aiScore += 10; }
  return { score: Math.max(0, score), aiScore, signals };
}

async function bskyFetch(path) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), 15000);
  try {
    const res = await fetch(`${BSKY_PUBLIC}${path}`, { signal: controller.signal });
    clearTimeout(timer);
    if (!res.ok) return null;
    return await res.json();
  } catch { clearTimeout(timer); return null; }
}

async function bskyDiscover(opts = {}) {
  const minScore = opts.minScore || 20;
  const limit = opts.limit || 30;
  const candidates = new Map();
  for (const q of BSKY_SEARCH_QUERIES) {
    const data = await bskyFetch(`/xrpc/app.bsky.actor.searchActors?q=${encodeURIComponent(q)}&limit=25`);
    if (!data?.actors) continue;
    for (const actor of data.actors) {
      if (candidates.has(actor.handle)) continue;
      const { score, aiScore, signals } = bskyScoreProfile(actor);
      candidates.set(actor.handle, { actor, score, aiScore, signals });
    }
    await new Promise(r => setTimeout(r, 300));
  }
  if (opts.followGraph !== false) {
    const seeds = [...candidates.values()].filter(c => c.score >= 40).sort((a, b) => b.score - a.score).slice(0, 5);
    for (const seed of seeds) {
      const data = await bskyFetch(`/xrpc/app.bsky.graph.getFollows?actor=${encodeURIComponent(seed.actor.did)}&limit=50`);
      if (!data?.follows) continue;
      for (const actor of data.follows) {
        if (candidates.has(actor.handle)) continue;
        const { score, aiScore, signals } = bskyScoreProfile(actor);
        if (score > 0) { signals.push(`followed_by:@${seed.actor.handle.split(".")[0]}`); candidates.set(actor.handle, { actor, score: score + 10, aiScore, signals }); }
      }
      await new Promise(r => setTimeout(r, 300));
    }
  }
  let results = [...candidates.values()].filter(c => c.score >= minScore).sort((a, b) => b.score - a.score).slice(0, limit * 2);
  if (opts.analyzePosts !== false) {
    for (const r of results.slice(0, 20)) {
      const data = await bskyFetch(`/xrpc/app.bsky.feed.getAuthorFeed?actor=${encodeURIComponent(r.actor.did)}&limit=10`);
      if (!data?.feed) continue;
      let hits = 0;
      for (const item of data.feed) { const text = item.post?.record?.text || ""; for (const re of BSKY_POST_RE) { if (re.test(text)) { hits++; break; } } }
      const ratio = data.feed.length > 0 ? hits / data.feed.length : 0;
      if (ratio > 0.3) { r.score += 20; r.signals.push(`bot_posts:${(ratio*100).toFixed(0)}%`); }
      else if (ratio > 0.1) { r.score += 10; r.signals.push(`some_bot_posts`); }
      await new Promise(r => setTimeout(r, 200));
    }
    results.sort((a, b) => b.score - a.score);
  }
  return results.slice(0, limit);
}

export function register(server) {
  server.tool("moltbook_bsky_discover", "Discover AI agent accounts on Bluesky using multi-signal heuristics + follow-graph traversal", {
    limit: z.number().min(1).max(50).default(20).optional().describe("Max agents to return"),
    min_score: z.number().default(20).optional().describe("Minimum score threshold"),
    ai_only: z.boolean().default(false).optional().describe("Only return agents with AI signals"),
    follow_graph: z.boolean().default(true).optional().describe("Traverse follow graphs of top candidates"),
    analyze_posts: z.boolean().default(true).optional().describe("Analyze recent posts for bot patterns"),
  }, async ({ limit, min_score, ai_only, follow_graph, analyze_posts }) => {
    try {
      let results = await bskyDiscover({ limit: (limit || 20) * 2, minScore: min_score || 20, followGraph: follow_graph !== false, analyzePosts: analyze_posts !== false });
      if (ai_only) results = results.filter(r => r.aiScore > 0);
      results = results.slice(0, limit || 20);
      if (!results.length) return { content: [{ type: "text", text: "No Bluesky agents found matching criteria." }] };
      const catalog = results.map(r => ({ handle: r.actor.handle, displayName: r.actor.displayName || null, did: r.actor.did, score: r.score, aiScore: r.aiScore, signals: r.signals, followers: r.actor.followersCount || 0, following: r.actor.followsCount || 0, posts: r.actor.postsCount || 0, discoveredAt: new Date().toISOString() }));
      let previousHandles = new Set();
      try { const prev = JSON.parse(readFileSync(BSKY_CATALOG_PATH, "utf8")); previousHandles = new Set(prev.map(e => e.handle)); } catch {}
      const newAgents = catalog.filter(a => !previousHandles.has(a.handle));
      writeFileSync(BSKY_CATALOG_PATH, JSON.stringify(catalog, null, 2));
      const lines = results.map(r => {
        const bio = (r.actor.description || "").slice(0, 80).replace(/\n/g, " ");
        const isNew = !previousHandles.has(r.actor.handle);
        return `[${r.score}${r.aiScore ? ` ai:${r.aiScore}` : ""}] @${r.actor.handle}${isNew ? " ðŸ†•" : ""}\n  ${r.actor.displayName || "-"} | ${bio}\n  signals: ${r.signals.slice(0, 5).join(", ")}`;
      });
      let header = `Bluesky Agent Discovery: ${results.length} agents found (min score: ${min_score || 20})`;
      if (newAgents.length) header += `\nðŸ†• ${newAgents.length} new since last scan`;
      header += `\nCatalog saved to bsky-agents.json`;
      return { content: [{ type: "text", text: `${header}\n\n${lines.join("\n\n")}` }] };
    } catch (e) { return { content: [{ type: "text", text: `Discovery error: ${e.message}` }] }; }
  });
}
