#!/usr/bin/env node
// cron.test.mjs â€” Tests for cron.js component
// Generated by generate-test-scaffold.mjs (wq-159), enhanced with fetch mocking
// Run with: node --test components/cron.test.mjs

import { test, describe, before, after, beforeEach, mock } from 'node:test';
import assert from 'node:assert/strict';
import { mkdirSync } from 'fs';
import { join } from 'path';

// Set up isolated test environment
const TEST_HOME = '/tmp/cron-test-' + Date.now();
const TEST_STATE_DIR = join(TEST_HOME, '.config/moltbook');
process.env.HOME = TEST_HOME;
mkdirSync(TEST_STATE_DIR, { recursive: true });

// Mock fetch for API calls
let fetchMock;

// Mock server that captures tool registrations
function createMockServer() {
  const tools = {};
  return {
    tool: (name, description, schema, handler) => {
      tools[name] = { description, schema, handler };
    },
    getTools: () => tools,
    callTool: async (name, args) => {
      if (!tools[name]) throw new Error(`Tool ${name} not found`);
      return tools[name].handler(args);
    }
  };
}

// Extract text from tool result
function getText(result) {
  return result?.content?.[0]?.text || '';
}

describe('cron.js component', () => {
  let server;

  before(async () => {
    const mod = await import('./cron.js');
    server = createMockServer();
    mod.register(server, { sessionNum: 100, sessionType: 'B' });
  });

  after(() => {
    mock.reset();
  });

  beforeEach(() => {
    fetchMock = mock.fn();
    global.fetch = fetchMock;
  });

  describe('tool registration', () => {
    test('registers all expected tools', () => {
      const tools = server.getTools();
      const expectedTools = [
        "cron_create",
        "cron_list",
        "cron_get",
        "cron_delete",
        "cron_update"
      ];

      for (const toolName of expectedTools) {
        assert.ok(tools[toolName], `Tool ${toolName} should be registered`);
      }
    });
  });

  describe('cron_create', () => {
    test('creates job successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          id: 'job-123',
          name: 'Test Job',
          method: 'POST',
          url: 'https://example.com/callback',
          interval: 300
        })
      }));

      const result = await server.callTool('cron_create', {
        url: 'https://example.com/callback',
        interval: 300,
        name: 'Test Job'
      });
      const text = getText(result);

      assert.ok(text.includes('job-123'), 'Should return job ID');
      assert.ok(text.includes('Test Job'), 'Should include job name');
      assert.ok(text.includes('300s'), 'Should include interval');
    });

    test('handles API error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ error: 'Invalid interval' })
      }));

      const result = await server.callTool('cron_create', {
        url: 'https://example.com',
        interval: 10 // too short
      });
      const text = getText(result);

      assert.ok(text.includes('failed') || text.includes('error'), 'Should indicate failure');
    });

    test('handles network error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.reject(new Error('Network unavailable')));

      const result = await server.callTool('cron_create', {
        url: 'https://example.com',
        interval: 300
      });
      const text = getText(result);

      assert.ok(text.includes('error'), 'Should indicate error');
    });
  });

  describe('cron_list', () => {
    test('lists jobs successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          total: 2,
          jobs: [
            { id: 'job-1', name: 'Job One', method: 'POST', url: 'https://a.com', interval: 60, active: true, run_count: 5, error_count: 0 },
            { id: 'job-2', method: 'GET', url: 'https://b.com', interval: 120, active: false, run_count: 10, error_count: 2 }
          ]
        })
      }));

      const result = await server.callTool('cron_list', {});
      const text = getText(result);

      assert.ok(text.includes('2 cron job'), 'Should show count');
      assert.ok(text.includes('job-1'), 'Should include first job');
      assert.ok(text.includes('job-2'), 'Should include second job');
      assert.ok(text.includes('active'), 'Should show active status');
      assert.ok(text.includes('paused'), 'Should show paused status');
    });

    test('handles empty list', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ total: 0, jobs: [] })
      }));

      const result = await server.callTool('cron_list', {});
      const text = getText(result);

      assert.ok(text.includes('No cron jobs'), 'Should indicate empty list');
    });
  });

  describe('cron_get', () => {
    test('gets job details', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({
          id: 'job-123',
          name: 'Heartbeat',
          method: 'POST',
          url: 'https://example.com/heartbeat',
          interval: 300,
          active: true,
          run_count: 100,
          error_count: 5,
          created_at: '2026-01-01T00:00:00Z',
          history: [
            { ts: '2026-02-04T12:00:00Z', status: 200, duration_ms: 150 },
            { ts: '2026-02-04T12:05:00Z', status: 500, duration_ms: 50, error: 'Server error' }
          ]
        })
      }));

      const result = await server.callTool('cron_get', { id: 'job-123' });
      const text = getText(result);

      assert.ok(text.includes('job-123'), 'Should include job ID');
      assert.ok(text.includes('Heartbeat'), 'Should include name');
      assert.ok(text.includes('300s'), 'Should include interval');
      assert.ok(text.includes('Recent runs'), 'Should include history');
    });

    test('handles not found', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        status: 404
      }));

      const result = await server.callTool('cron_get', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('not found'), 'Should indicate not found');
    });
  });

  describe('cron_delete', () => {
    test('deletes job successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200
      }));

      const result = await server.callTool('cron_delete', { id: 'job-123' });
      const text = getText(result);

      assert.ok(text.includes('Deleted') || text.includes('deleted'), 'Should confirm deletion');
      assert.ok(text.includes('job-123'), 'Should include job ID');
    });

    test('handles not found', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        status: 404
      }));

      const result = await server.callTool('cron_delete', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('not found'), 'Should indicate not found');
    });
  });

  describe('cron_update', () => {
    test('updates job successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({
          id: 'job-123',
          active: false,
          interval: 600
        })
      }));

      const result = await server.callTool('cron_update', {
        id: 'job-123',
        active: false,
        interval: 600
      });
      const text = getText(result);

      assert.ok(text.includes('Updated') || text.includes('updated'), 'Should confirm update');
      assert.ok(text.includes('job-123'), 'Should include job ID');
    });

    test('handles not found', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        status: 404
      }));

      const result = await server.callTool('cron_update', { id: 'nonexistent', active: true });
      const text = getText(result);

      assert.ok(text.includes('not found'), 'Should indicate not found');
    });

    test('handles update error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ error: 'Invalid interval' })
      }));

      const result = await server.callTool('cron_update', { id: 'job-123', interval: 10 });
      const text = getText(result);

      assert.ok(text.includes('failed') || text.includes('Invalid'), 'Should indicate failure');
    });
  });
});
