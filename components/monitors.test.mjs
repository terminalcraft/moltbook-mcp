#!/usr/bin/env node
// monitors.test.mjs â€” Tests for monitors.js component
// Generated by generate-test-scaffold.mjs (wq-159), enhanced with fetch mocking
// Run with: node --test components/monitors.test.mjs

import { test, describe, before, after, beforeEach, mock } from 'node:test';
import assert from 'node:assert/strict';
import { mkdirSync } from 'fs';
import { join } from 'path';

// Set up isolated test environment
const TEST_HOME = '/tmp/monitors-test-' + Date.now();
const TEST_STATE_DIR = join(TEST_HOME, '.config/moltbook');
process.env.HOME = TEST_HOME;
mkdirSync(TEST_STATE_DIR, { recursive: true });

// Mock fetch for API calls
let fetchMock;

// Mock server that captures tool registrations
function createMockServer() {
  const tools = {};
  return {
    tool: (name, description, schema, handler) => {
      tools[name] = { description, schema, handler };
    },
    getTools: () => tools,
    callTool: async (name, args) => {
      if (!tools[name]) throw new Error(`Tool ${name} not found`);
      return tools[name].handler(args);
    }
  };
}

// Extract text from tool result
function getText(result) {
  return result?.content?.[0]?.text || '';
}

describe('monitors.js component', () => {
  let server;

  before(async () => {
    const mod = await import('./monitors.js');
    server = createMockServer();
    mod.register(server, { sessionNum: 100, sessionType: 'B' });
  });

  after(() => {
    mock.reset();
  });

  beforeEach(() => {
    fetchMock = mock.fn();
    global.fetch = fetchMock;
  });

  describe('tool registration', () => {
    test('registers all expected tools', () => {
      const tools = server.getTools();
      const expectedTools = [
        "monitor_create",
        "monitor_list",
        "monitor_get",
        "monitor_delete",
        "monitor_probe"
      ];

      for (const toolName of expectedTools) {
        assert.ok(tools[toolName], `Tool ${toolName} should be registered`);
      }
    });
  });

  describe('monitor_create', () => {
    test('creates monitor successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          id: 'mon-abc123',
          name: 'My API',
          url: 'https://api.example.com/health'
        })
      }));

      const result = await server.callTool('monitor_create', {
        agent: 'moltbook',
        url: 'https://api.example.com/health',
        name: 'My API'
      });
      const text = getText(result);

      assert.ok(text.includes('mon-abc123'), 'Should return monitor ID');
      assert.ok(text.includes('My API'), 'Should include monitor name');
    });

    test('handles duplicate URL error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({
          error: 'URL already monitored',
          id: 'mon-existing'
        })
      }));

      const result = await server.callTool('monitor_create', {
        agent: 'moltbook',
        url: 'https://api.example.com/health'
      });
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
      assert.ok(text.includes('mon-existing'), 'Should include existing ID');
    });

    test('handles network error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.reject(new Error('Connection refused')));

      const result = await server.callTool('monitor_create', {
        agent: 'moltbook',
        url: 'https://api.example.com'
      });
      const text = getText(result);

      assert.ok(text.includes('error'), 'Should indicate error');
    });
  });

  describe('monitor_list', () => {
    test('lists monitors successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          total: 2,
          max: 10,
          monitors: [
            { id: 'mon-1', name: 'API', status: 'up', uptime_1h: 100, uptime_24h: 99.5, agent: 'moltbook' },
            { id: 'mon-2', name: 'Website', status: 'down', uptime_1h: 50, uptime_24h: 75, agent: 'moltbook' }
          ]
        })
      }));

      const result = await server.callTool('monitor_list', {});
      const text = getText(result);

      assert.ok(text.includes('2/10 monitors'), 'Should show count and max');
      assert.ok(text.includes('mon-1'), 'Should include first monitor');
      assert.ok(text.includes('mon-2'), 'Should include second monitor');
      assert.ok(text.includes('up'), 'Should show status');
      assert.ok(text.includes('100%'), 'Should show uptime');
    });

    test('handles empty list', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ total: 0, max: 10, monitors: [] })
      }));

      const result = await server.callTool('monitor_list', {});
      const text = getText(result);

      assert.ok(text.includes('No monitors'), 'Should indicate empty list');
    });

    test('handles null uptime values', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          total: 1,
          max: 10,
          monitors: [
            { id: 'mon-new', name: 'New', status: 'pending', uptime_1h: null, uptime_24h: null, agent: 'moltbook' }
          ]
        })
      }));

      const result = await server.callTool('monitor_list', {});
      const text = getText(result);

      assert.ok(text.includes('--'), 'Should show -- for null uptime');
    });
  });

  describe('monitor_get', () => {
    test('gets monitor details', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({
          id: 'mon-123',
          name: 'Production API',
          url: 'https://api.prod.com/health',
          agent: 'moltbook',
          status: 'up',
          status_code: 200,
          uptime_1h: 100,
          uptime_24h: 99.8,
          last_checked: '2026-02-04T12:00:00Z',
          history: [
            { ts: '2026-02-04T12:00:00Z', status: 'up' },
            { ts: '2026-02-04T11:55:00Z', status: 'up' }
          ]
        })
      }));

      const result = await server.callTool('monitor_get', { id: 'mon-123' });
      const text = getText(result);

      assert.ok(text.includes('Production API'), 'Should include name');
      assert.ok(text.includes('https://api.prod.com/health'), 'Should include URL');
      assert.ok(text.includes('100%'), 'Should include uptime');
      assert.ok(text.includes('Recent history'), 'Should include history');
    });

    test('handles not found', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        status: 404
      }));

      const result = await server.callTool('monitor_get', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('not found'), 'Should indicate not found');
    });
  });

  describe('monitor_delete', () => {
    test('deletes monitor successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ removed: 'mon-123' })
      }));

      const result = await server.callTool('monitor_delete', { id: 'mon-123' });
      const text = getText(result);

      assert.ok(text.includes('Deleted'), 'Should confirm deletion');
      assert.ok(text.includes('mon-123'), 'Should include monitor ID');
    });

    test('handles delete error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ error: 'Not your monitor' })
      }));

      const result = await server.callTool('monitor_delete', { id: 'mon-other' });
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
    });
  });

  describe('monitor_probe', () => {
    test('probes monitor successfully - no change', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          name: 'My API',
          status: 'up',
          status_code: 200,
          changed: false
        })
      }));

      const result = await server.callTool('monitor_probe', { id: 'mon-123' });
      const text = getText(result);

      assert.ok(text.includes('Probed'), 'Should confirm probe');
      assert.ok(text.includes('My API'), 'Should include name');
      assert.ok(text.includes('up'), 'Should include status');
      assert.ok(text.includes('200'), 'Should include status code');
    });

    test('probes monitor - status changed', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          name: 'My API',
          status: 'down',
          status_code: 503,
          changed: true,
          previous: 'up'
        })
      }));

      const result = await server.callTool('monitor_probe', { id: 'mon-123' });
      const text = getText(result);

      assert.ok(text.includes('down'), 'Should include new status');
      assert.ok(text.includes('changed'), 'Should indicate change');
      assert.ok(text.includes('up'), 'Should include previous status');
    });

    test('handles probe error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ error: 'Monitor not found' })
      }));

      const result = await server.callTool('monitor_probe', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
    });
  });
});
