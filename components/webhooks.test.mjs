#!/usr/bin/env node
// webhooks.test.mjs â€” Tests for webhooks.js component
// Generated by generate-test-scaffold.mjs (wq-159), enhanced with fetch mocking
// Run with: node --test components/webhooks.test.mjs

import { test, describe, before, after, beforeEach, mock } from 'node:test';
import assert from 'node:assert/strict';
import { mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';

// Set up isolated test environment
const TEST_HOME = '/tmp/webhooks-test-' + Date.now();
const TEST_STATE_DIR = join(TEST_HOME, '.config/moltbook');
process.env.HOME = TEST_HOME;
mkdirSync(TEST_STATE_DIR, { recursive: true });

// Create dummy api-token file for auth
writeFileSync(join(TEST_STATE_DIR, 'api-token'), 'test-token-12345');

// Mock fetch for API calls
let fetchMock;

// Mock server that captures tool registrations
function createMockServer() {
  const tools = {};
  return {
    tool: (name, description, schema, handler) => {
      tools[name] = { description, schema, handler };
    },
    getTools: () => tools,
    callTool: async (name, args) => {
      if (!tools[name]) throw new Error(`Tool ${name} not found`);
      return tools[name].handler(args);
    }
  };
}

// Extract text from tool result
function getText(result) {
  return result?.content?.[0]?.text || '';
}

describe('webhooks.js component', () => {
  let server;

  before(async () => {
    const mod = await import('./webhooks.js');
    server = createMockServer();
    mod.register(server, { sessionNum: 100, sessionType: 'B' });
  });

  after(() => {
    mock.reset();
  });

  beforeEach(() => {
    fetchMock = mock.fn();
    global.fetch = fetchMock;
  });

  describe('tool registration', () => {
    test('registers all expected tools', () => {
      const tools = server.getTools();
      const expectedTools = [
        "webhooks_subscribe",
        "webhooks_list",
        "webhooks_delete",
        "webhooks_events",
        "webhooks_stats"
      ];

      for (const toolName of expectedTools) {
        assert.ok(tools[toolName], `Tool ${toolName} should be registered`);
      }
    });
  });

  describe('webhooks_subscribe', () => {
    test('creates new webhook successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          id: 'wh-abc123',
          secret: 'secret-xyz',
          events: ['pattern.added', 'knowledge.exchanged'],
          updated: false
        })
      }));

      const result = await server.callTool('webhooks_subscribe', {
        agent: 'moltbook',
        url: 'https://example.com/webhook',
        events: ['pattern.added', 'knowledge.exchanged']
      });
      const text = getText(result);

      assert.ok(text.includes('wh-abc123'), 'Should return webhook ID');
      assert.ok(text.includes('secret-xyz'), 'Should include secret');
      assert.ok(text.includes('created'), 'Should indicate creation');
    });

    test('updates existing webhook', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          id: 'wh-abc123',
          events: ['pattern.added', 'chatr.message'],
          updated: true
        })
      }));

      const result = await server.callTool('webhooks_subscribe', {
        agent: 'moltbook',
        url: 'https://example.com/webhook',
        events: ['pattern.added', 'chatr.message']
      });
      const text = getText(result);

      assert.ok(text.includes('Updated'), 'Should indicate update');
      assert.ok(text.includes('wh-abc123'), 'Should include webhook ID');
    });

    test('handles invalid events error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({
          error: 'Invalid event',
          valid: ['pattern.added', 'knowledge.exchanged', 'chatr.message']
        })
      }));

      const result = await server.callTool('webhooks_subscribe', {
        agent: 'moltbook',
        url: 'https://example.com/webhook',
        events: ['invalid.event']
      });
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
      assert.ok(text.includes('Valid events'), 'Should list valid events');
    });

    test('handles network error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.reject(new Error('Connection refused')));

      const result = await server.callTool('webhooks_subscribe', {
        agent: 'moltbook',
        url: 'https://example.com/webhook',
        events: ['pattern.added']
      });
      const text = getText(result);

      assert.ok(text.includes('error'), 'Should indicate error');
    });
  });

  describe('webhooks_list', () => {
    test('lists webhooks successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve([
          { id: 'wh-1', url: 'https://a.com/hook', events: ['pattern.added'], agent: 'agent1' },
          { id: 'wh-2', url: 'https://b.com/hook', events: ['*'], agent: 'agent2' }
        ])
      }));

      const result = await server.callTool('webhooks_list', {});
      const text = getText(result);

      assert.ok(text.includes('2 webhook'), 'Should show count');
      assert.ok(text.includes('wh-1'), 'Should include first webhook');
      assert.ok(text.includes('wh-2'), 'Should include second webhook');
      assert.ok(text.includes('https://a.com/hook'), 'Should include URL');
    });

    test('handles empty list', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve([])
      }));

      const result = await server.callTool('webhooks_list', {});
      const text = getText(result);

      assert.ok(text.includes('No webhooks'), 'Should indicate empty list');
    });

    test('handles list error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ error: 'Unauthorized' })
      }));

      const result = await server.callTool('webhooks_list', {});
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
    });
  });

  describe('webhooks_delete', () => {
    test('deletes webhook successfully', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      }));

      const result = await server.callTool('webhooks_delete', { id: 'wh-abc123' });
      const text = getText(result);

      assert.ok(text.includes('deleted'), 'Should confirm deletion');
      assert.ok(text.includes('wh-abc123'), 'Should include webhook ID');
    });

    test('handles delete error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        json: () => Promise.resolve({ error: 'Webhook not found' })
      }));

      const result = await server.callTool('webhooks_delete', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('failed'), 'Should indicate failure');
    });
  });

  describe('webhooks_events', () => {
    test('lists available events', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          events: ['pattern.added', 'pattern.updated', 'knowledge.exchanged', 'chatr.message', 'inbox.received']
        })
      }));

      const result = await server.callTool('webhooks_events', {});
      const text = getText(result);

      assert.ok(text.includes('Available webhook events'), 'Should have header');
      assert.ok(text.includes('pattern.added'), 'Should list event');
      assert.ok(text.includes('chatr.message'), 'Should list event');
      assert.ok(text.includes('*'), 'Should mention wildcard');
    });

    test('handles events error', async () => {
      fetchMock.mock.mockImplementation(() => Promise.reject(new Error('Server unavailable')));

      const result = await server.callTool('webhooks_events', {});
      const text = getText(result);

      assert.ok(text.includes('error'), 'Should indicate error');
    });
  });

  describe('webhooks_stats', () => {
    test('shows webhook stats', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({
          id: 'wh-abc123',
          agent: 'moltbook',
          url: 'https://example.com/webhook',
          events: ['pattern.added'],
          stats: {
            delivered: 42,
            failed: 3,
            last_delivery: '2026-02-04T12:00:00Z',
            last_failure: '2026-02-03T08:00:00Z'
          }
        })
      }));

      const result = await server.callTool('webhooks_stats', { id: 'wh-abc123' });
      const text = getText(result);

      assert.ok(text.includes('wh-abc123'), 'Should include webhook ID');
      assert.ok(text.includes('42'), 'Should show delivered count');
      assert.ok(text.includes('3'), 'Should show failed count');
      assert.ok(text.includes('moltbook'), 'Should show agent');
    });

    test('handles not found', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: false,
        status: 404
      }));

      const result = await server.callTool('webhooks_stats', { id: 'nonexistent' });
      const text = getText(result);

      assert.ok(text.includes('not found'), 'Should indicate not found');
    });

    test('handles stats with no failures', async () => {
      fetchMock.mock.mockImplementation(() => Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve({
          id: 'wh-new',
          agent: 'moltbook',
          url: 'https://example.com/webhook',
          events: ['*'],
          stats: {
            delivered: 10,
            failed: 0,
            last_delivery: '2026-02-04T12:00:00Z',
            last_failure: null
          }
        })
      }));

      const result = await server.callTool('webhooks_stats', { id: 'wh-new' });
      const text = getText(result);

      assert.ok(text.includes('0'), 'Should show zero failures');
      assert.ok(text.includes('none'), 'Should indicate no failures');
    });
  });
});
