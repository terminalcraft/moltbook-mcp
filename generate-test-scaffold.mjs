#!/usr/bin/env node
/**
 * generate-test-scaffold.mjs — Generate basic test scaffolds for components (wq-159)
 *
 * Usage:
 *   node generate-test-scaffold.mjs                     # List components without tests
 *   node generate-test-scaffold.mjs <component-name>    # Generate scaffold for specific component
 *   node generate-test-scaffold.mjs --all               # Generate scaffolds for all missing
 *   node generate-test-scaffold.mjs --force <name>      # Overwrite existing test file
 *
 * The generated scaffold includes:
 * - Mock server setup (same pattern as other component tests)
 * - Tool registration verification
 * - Basic test cases for each tool found
 */

import { readFileSync, writeFileSync, existsSync, readdirSync } from 'fs';
import { join, basename } from 'path';

const DIR = new URL('.', import.meta.url).pathname.replace(/\/$/, '');
const COMPONENTS_DIR = join(DIR, 'components');

// Find all component files (*.js, not *.test.*)
function getComponents() {
  const files = readdirSync(COMPONENTS_DIR);
  const components = files
    .filter(f => f.endsWith('.js') && !f.includes('.test.'))
    .map(f => f.replace('.js', ''));
  return components;
}

// Check if a test file exists for a component
function hasTest(name) {
  return existsSync(join(COMPONENTS_DIR, `${name}.test.mjs`)) ||
         existsSync(join(COMPONENTS_DIR, `${name}.test.js`));
}

// Extract tool registrations from a component file with their schemas
function extractTools(name) {
  const path = join(COMPONENTS_DIR, `${name}.js`);
  const content = readFileSync(path, 'utf8');

  const tools = [];
  // Match server.tool("name", desc, { schema }, handler) patterns
  // Capture tool name and try to extract required parameters
  const toolRegex = /server\.tool\(\s*["']([^"']+)["']\s*,\s*["'][^"']*["']\s*,\s*\{([^}]*)\}/gs;
  let match;
  while ((match = toolRegex.exec(content)) !== null) {
    const toolName = match[1];
    const schemaBlock = match[2];

    // Extract required string params (common pattern: param: z.string().describe(...))
    const params = [];
    const paramRegex = /(\w+):\s*z\.(string|number|boolean|array)/g;
    let paramMatch;
    while ((paramMatch = paramRegex.exec(schemaBlock)) !== null) {
      params.push({ name: paramMatch[1], type: paramMatch[2] });
    }

    tools.push({ name: toolName, params });
  }

  // Fallback: simple name extraction if complex regex didn't match
  if (tools.length === 0) {
    const simpleRegex = /server\.tool\(\s*["']([^"']+)["']/g;
    while ((match = simpleRegex.exec(content)) !== null) {
      tools.push({ name: match[1], params: [] });
    }
  }

  return tools;
}

// Check if component has onLoad export
function hasOnLoad(name) {
  const path = join(COMPONENTS_DIR, `${name}.js`);
  const content = readFileSync(path, 'utf8');
  return /export\s+function\s+onLoad/.test(content);
}

// Generate example args for a tool based on its parameters
function generateExampleArgs(params) {
  if (params.length === 0) return '{}';

  const args = params.map(p => {
    switch (p.type) {
      case 'string': return `${p.name}: 'test-${p.name}'`;
      case 'number': return `${p.name}: 1`;
      case 'boolean': return `${p.name}: true`;
      case 'array': return `${p.name}: []`;
      default: return `${p.name}: 'test'`;
    }
  });
  return `{ ${args.join(', ')} }`;
}

// Generate test scaffold for a component
function generateScaffold(name) {
  const tools = extractTools(name);
  const hasOnLoadFn = hasOnLoad(name);
  const toolNames = tools.map(t => t.name);

  const toolTests = tools.map(tool => {
    const exampleArgs = generateExampleArgs(tool.params);
    const paramInfo = tool.params.length > 0
      ? ` (params: ${tool.params.map(p => p.name).join(', ')})`
      : '';
    return `
    test('${tool.name} returns expected structure${paramInfo}', async () => {
      const result = await server.callTool('${tool.name}', ${exampleArgs});
      const text = getText(result);
      assert.ok(text, 'Should return text content');
    });`;
  }).join('\n');

  const toolList = toolNames.length > 0
    ? `const expectedTools = ${JSON.stringify(toolNames, null, 4)};`
    : `const expectedTools = []; // No tools found - component may use different registration pattern`;

  const scaffold = `#!/usr/bin/env node
// ${name}.test.mjs — Tests for ${name}.js component
// Generated by generate-test-scaffold.mjs (wq-159)
// Run with: node --test components/${name}.test.mjs

import { test, describe, before, after, mock } from 'node:test';
import assert from 'node:assert/strict';
import { mkdirSync } from 'fs';
import { join } from 'path';

// Set up isolated test environment
const TEST_HOME = '/tmp/${name}-test-' + Date.now();
const TEST_STATE_DIR = join(TEST_HOME, '.config/moltbook');
process.env.HOME = TEST_HOME;
mkdirSync(TEST_STATE_DIR, { recursive: true });

// Mock server that captures tool registrations
function createMockServer() {
  const tools = {};
  return {
    tool: (name, description, schema, handler) => {
      tools[name] = { description, schema, handler };
    },
    getTools: () => tools,
    callTool: async (name, args) => {
      if (!tools[name]) throw new Error(\`Tool \${name} not found\`);
      return tools[name].handler(args);
    }
  };
}

// Extract text from tool result
function getText(result) {
  return result?.content?.[0]?.text || '';
}

describe('${name}.js component', () => {
  let server;

  before(async () => {
    const mod = await import('./${name}.js');
    server = createMockServer();
    mod.register(server, { sessionNum: 100, sessionType: 'B' });
  });

  after(() => {
    mock.reset();
  });

  describe('tool registration', () => {
    test('registers all expected tools', () => {
      const tools = server.getTools();
      ${toolList}

      for (const toolName of expectedTools) {
        assert.ok(tools[toolName], \`Tool \${toolName} should be registered\`);
      }
    });
  });

  // Tool functionality tests - auto-generated with example parameters
  describe('tool functionality', () => {${toolTests.length > 0 ? toolTests : `
    test('placeholder - add specific tests', () => {
      assert.ok(true, 'Replace this with actual tests');
    });`}
  });
});
`;

  return scaffold;
}

// Main
const args = process.argv.slice(2);

if (args.length === 0) {
  // List components without tests
  const components = getComponents();
  const missing = components.filter(c => !hasTest(c));

  console.log(`Component test coverage: ${components.length - missing.length}/${components.length}\n`);

  if (missing.length === 0) {
    console.log('All components have test files!');
  } else {
    console.log('Components without tests:');
    for (const name of missing) {
      const tools = extractTools(name);
      console.log(`  ${name}.js (${tools.length} tools)`);
    }
    console.log(`\nRun: node generate-test-scaffold.mjs <name> to generate a scaffold`);
  }
  process.exit(0);
}

if (args[0] === '--all') {
  const components = getComponents();
  const missing = components.filter(c => !hasTest(c));

  for (const name of missing) {
    const scaffold = generateScaffold(name);
    const testPath = join(COMPONENTS_DIR, `${name}.test.mjs`);
    writeFileSync(testPath, scaffold);
    console.log(`Generated: ${name}.test.mjs`);
  }

  console.log(`\nGenerated ${missing.length} test scaffold(s)`);
  process.exit(0);
}

const force = args[0] === '--force';
const name = force ? args[1] : args[0];

if (!name) {
  console.error('Usage: node generate-test-scaffold.mjs <component-name>');
  process.exit(1);
}

const componentPath = join(COMPONENTS_DIR, `${name}.js`);
if (!existsSync(componentPath)) {
  console.error(`Component not found: ${name}.js`);
  process.exit(1);
}

const testPath = join(COMPONENTS_DIR, `${name}.test.mjs`);
if (existsSync(testPath) && !force) {
  console.error(`Test file already exists: ${name}.test.mjs`);
  console.error('Use --force to overwrite');
  process.exit(1);
}

const scaffold = generateScaffold(name);
writeFileSync(testPath, scaffold);

const tools = extractTools(name);
const toolNames = tools.map(t => t.name);
console.log(`Generated: ${name}.test.mjs`);
console.log(`  Tools found: ${tools.length} (${toolNames.join(', ') || 'none'})`);
console.log(`\nNext steps:`);
console.log(`  1. Review and customize the generated tests`);
console.log(`  2. Run: node --test components/${name}.test.mjs`);
