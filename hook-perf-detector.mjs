#!/usr/bin/env node
/**
 * hook-perf-detector.mjs — Detect hook performance regressions and surface fix recommendations.
 *
 * Reads hook-timing-profiles.json (generated by hook-timing-tuner.mjs),
 * identifies hooks consuming >50% of their timeout budget, and outputs
 * actionable recommendations (cache, async, split, retire).
 *
 * Usage: node hook-perf-detector.mjs [--json] [--threshold <pct>]
 *   --json       Output JSON instead of human-readable text
 *   --threshold  Percent of timeout budget to flag (default: 50)
 *
 * Exit codes:
 *   0 = no regressions
 *   1 = regressions found
 *   2 = error reading data
 *
 * Created: B#380 (wq-478)
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

const PROFILES_PATH = join(homedir(), '.config/moltbook/hook-timing-profiles.json');
const JSON_OUTPUT = process.argv.includes('--json');
const thresholdIdx = process.argv.indexOf('--threshold');
const THRESHOLD_PCT = thresholdIdx !== -1 ? parseInt(process.argv[thresholdIdx + 1], 10) : 50;

if (!existsSync(PROFILES_PATH)) {
  console.error('No hook-timing-profiles.json found. Run hook-timing-tuner.mjs first.');
  process.exit(2);
}

let profiles;
try {
  profiles = JSON.parse(readFileSync(PROFILES_PATH, 'utf8'));
} catch (e) {
  console.error(`Failed to parse profiles: ${e.message}`);
  process.exit(2);
}

// Analyze a single phase (pre_session or post_session)
function analyzePhase(phaseName, phaseData) {
  if (!phaseData?.profiles) return [];

  const findings = [];

  for (const [hook, stats] of Object.entries(phaseData.profiles)) {
    const timeoutMs = stats.recommended_timeout_secs * 1000;
    const budgetPct = timeoutMs > 0 ? Math.round((stats.p95_ms / timeoutMs) * 100) : 0;
    const issues = [];

    // Check 1: P95 consuming >threshold% of timeout budget
    if (budgetPct >= THRESHOLD_PCT) {
      issues.push({
        type: 'budget_pressure',
        detail: `P95 (${stats.p95_ms}ms) uses ${budgetPct}% of ${stats.recommended_timeout_secs}s timeout`,
      });
    }

    // Check 2: High timeout rate (>5%)
    if (stats.timeout_rate_pct > 5) {
      issues.push({
        type: 'chronic_timeout',
        detail: `${stats.timeout_rate_pct}% timeout rate (${stats.timeout_count}/${stats.samples} executions)`,
      });
    }

    // Check 3: High failure rate (>10%)
    const failureRate = stats.samples > 0 ? Math.round((stats.failure_count / stats.samples) * 100) : 0;
    if (failureRate > 10) {
      issues.push({
        type: 'high_failure',
        detail: `${failureRate}% failure rate (${stats.failure_count}/${stats.samples} executions)`,
      });
    }

    // Check 4: High variance (P99/P50 ratio > 10x suggests intermittent slowness)
    const varianceRatio = stats.p50_ms > 0 ? Math.round(stats.p99_ms / stats.p50_ms) : 0;
    if (varianceRatio > 10 && stats.p99_ms > 1000) {
      issues.push({
        type: 'high_variance',
        detail: `P99/P50 ratio is ${varianceRatio}x (${stats.p50_ms}ms → ${stats.p99_ms}ms) — likely intermittent network or I/O`,
      });
    }

    if (issues.length > 0) {
      findings.push({
        hook,
        phase: phaseName,
        stats: {
          p50_ms: stats.p50_ms,
          p95_ms: stats.p95_ms,
          p99_ms: stats.p99_ms,
          max_ms: stats.max_ms,
          mean_ms: stats.mean_ms,
          samples: stats.samples,
          timeout_rate_pct: stats.timeout_rate_pct,
          failure_count: stats.failure_count,
        },
        issues,
        recommendations: generateRecommendations(hook, stats, issues),
      });
    }
  }

  // Sort by severity: chronic_timeout first, then budget_pressure by P95
  findings.sort((a, b) => {
    const aHasTimeout = a.issues.some(i => i.type === 'chronic_timeout');
    const bHasTimeout = b.issues.some(i => i.type === 'chronic_timeout');
    if (aHasTimeout !== bHasTimeout) return aHasTimeout ? -1 : 1;
    return b.stats.p95_ms - a.stats.p95_ms;
  });

  return findings;
}

function generateRecommendations(hook, stats, issues) {
  const recs = [];
  const hasTimeout = issues.some(i => i.type === 'chronic_timeout');
  const hasVariance = issues.some(i => i.type === 'high_variance');
  const hasFailure = issues.some(i => i.type === 'high_failure');

  // Network-dependent hooks (contain curl, fetch, API calls)
  const networkPatterns = ['liveness', 'health-check', 'circuit-reset', 'presence', 'imanagent', 'service-liveness'];
  const isNetworkHook = networkPatterns.some(p => hook.includes(p));

  if (hasTimeout && isNetworkHook) {
    recs.push({
      action: 'add_timeout_cap',
      detail: 'Add per-endpoint timeout (e.g., curl --max-time 3) to prevent 30s hangs on unreachable hosts',
      effort: 'low',
    });
    recs.push({
      action: 'add_caching',
      detail: 'Cache probe results for 5 minutes — skip re-probing recently-checked endpoints',
      effort: 'medium',
    });
  }

  if (hasTimeout && !isNetworkHook) {
    recs.push({
      action: 'investigate',
      detail: 'Non-network hook timing out — check for disk I/O, jq on large files, or subprocess hangs',
      effort: 'medium',
    });
  }

  if (hasVariance && isNetworkHook) {
    recs.push({
      action: 'async_probe',
      detail: 'Run network probes in parallel (background subshells) instead of sequential',
      effort: 'medium',
    });
  }

  if (hasVariance && !isNetworkHook) {
    recs.push({
      action: 'profile_outliers',
      detail: 'The P50 is fast but P99 spikes — add timing instrumentation to identify the slow path',
      effort: 'low',
    });
  }

  if (hasFailure && stats.failure_count > stats.timeout_count) {
    const nonTimeoutFailures = stats.failure_count - stats.timeout_count;
    recs.push({
      action: 'fix_errors',
      detail: `${nonTimeoutFailures} non-timeout failures — check exit codes and error handling`,
      effort: 'medium',
    });
  }

  if (stats.p95_ms > 5000 && !hasTimeout) {
    recs.push({
      action: 'split_hook',
      detail: 'P95 > 5s — consider splitting into fast (critical) and slow (deferrable) parts',
      effort: 'high',
    });
  }

  if (stats.mean_ms > 2000 && stats.samples >= 50) {
    recs.push({
      action: 'budget_review',
      detail: `Mean ${stats.mean_ms}ms across ${stats.samples} samples — this hook consistently eats session startup budget`,
      effort: 'low',
    });
  }

  // If no specific recommendations, add a generic one
  if (recs.length === 0) {
    recs.push({
      action: 'review',
      detail: 'Review hook implementation for optimization opportunities',
      effort: 'low',
    });
  }

  return recs;
}

// Run analysis
const preFindings = analyzePhase('pre_session', profiles.pre_session);
const postFindings = analyzePhase('post_session', profiles.post_session);
const allFindings = [...preFindings, ...postFindings];

if (JSON_OUTPUT) {
  const report = {
    generated_at: new Date().toISOString(),
    profiles_from: profiles.generated_at,
    threshold_pct: THRESHOLD_PCT,
    total_findings: allFindings.length,
    pre_session: preFindings,
    post_session: postFindings,
  };
  console.log(JSON.stringify(report, null, 2));
} else {
  // Human-readable output
  if (allFindings.length === 0) {
    console.log(`Hook performance: all clear (threshold: ${THRESHOLD_PCT}% budget usage)`);
    process.exit(0);
  }

  console.log(`Hook Performance Report (threshold: ${THRESHOLD_PCT}% budget usage)`);
  console.log(`Profiles from: ${profiles.generated_at}`);
  console.log(`Findings: ${allFindings.length} hooks need attention\n`);

  for (const f of allFindings) {
    const severity = f.issues.some(i => i.type === 'chronic_timeout') ? 'CRITICAL'
      : f.issues.some(i => i.type === 'high_failure') ? 'WARNING'
      : 'INFO';

    console.log(`[${severity}] ${f.phase}/${f.hook}`);
    console.log(`  P50=${f.stats.p50_ms}ms  P95=${f.stats.p95_ms}ms  P99=${f.stats.p99_ms}ms  max=${f.stats.max_ms}ms  (${f.stats.samples} samples)`);

    for (const issue of f.issues) {
      console.log(`  Issue: ${issue.detail}`);
    }

    console.log('  Recommendations:');
    for (const rec of f.recommendations) {
      console.log(`    [${rec.effort}] ${rec.action}: ${rec.detail}`);
    }
    console.log('');
  }
}

process.exit(allFindings.length > 0 ? 1 : 0);
