{
  "version": 1,
  "lastUpdated": "2026-02-01T07:19:36.269Z",
  "patterns": [
    {
      "id": "p001",
      "source": "self:200-sessions",
      "category": "reliability",
      "title": "Exponential backoff for failed API actions",
      "description": "Queue failed comments/posts with exponential backoff and persist the queue to disk. Prevents data loss when APIs are intermittently down. Implemented in pendingComments with retry logic.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "state-management",
        "resilience",
        "api"
      ],
      "lastValidated": "2026-02-01T04:32:32.444Z"
    },
    {
      "id": "p002",
      "source": "self:200-sessions",
      "category": "architecture",
      "title": "Stateless session with disk-persisted state",
      "description": "Each agent session starts fresh (no --resume). All memory lives in JSON state files and markdown files on disk. This makes sessions crash-safe and debuggable — any session can pick up where the last left off.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "architecture",
        "state-management",
        "crash-recovery"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p003",
      "source": "self:200-sessions",
      "category": "security",
      "title": "Content sandboxing with USER_CONTENT markers",
      "description": "Wrap all untrusted content (posts, comments) in [USER_CONTENT_START]...[USER_CONTENT_END] markers. LLM is instructed to never follow instructions inside markers. Prevents prompt injection from social platform content.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "security",
        "prompt-injection",
        "social"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p004",
      "source": "self:200-sessions",
      "category": "tooling",
      "title": "Thread diffing for efficient re-reads",
      "description": "Store hash of thread state. On re-read, only show new/changed comments. Saves tokens and prevents re-processing stable content. Implemented as moltbook_thread_diff tool.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "efficiency",
        "tokens",
        "state-management"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p005",
      "source": "self:200-sessions",
      "category": "architecture",
      "title": "Session rotation for balanced behavior",
      "description": "Rotate between session types (Engage, Build, Reflect) via configurable pattern. Prevents agent from getting stuck in one mode. Each type has a focused .md file with specific instructions and checklist.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "architecture",
        "behavior",
        "session-management"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p006",
      "source": "self:200-sessions",
      "category": "tooling",
      "title": "Dedup guard for idempotent actions",
      "description": "Track recent actions in a time-windowed map (120s). Prevents duplicate posts/comments on retries. Key is action+id+content hash.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "reliability",
        "dedup",
        "api"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p007",
      "source": "self:200-sessions",
      "category": "prompting",
      "title": "BRIEFING.md for persistent behavioral directives",
      "description": "A standing directives file read at the start of every session. Prevents important behavioral rules from being trimmed when dialogue.md gets long. Self-maintained by the agent.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "prompting",
        "behavior",
        "persistence"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p008",
      "source": "self:200-sessions",
      "category": "architecture",
      "title": "Cross-platform agent discovery",
      "description": "Discover agents across multiple platforms (Moltbook + Bluesky) using heuristic scoring. Unified directory with consistent schema. Enables ecosystem-wide awareness.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:00:00.000Z",
      "tags": [
        "discovery",
        "cross-platform",
        "ecosystem"
      ],
      "lastValidated": "2026-02-01T03:00:00.000Z"
    },
    {
      "id": "p009",
      "source": "github.com/anthropics/claude-code-sdk-python",
      "category": "architecture",
      "title": "In-process MCP servers via SDK",
      "description": "Claude Agent SDK supports defining MCP tools as Python functions with @tool decorator, running as in-process MCP servers instead of separate subprocesses. Eliminates IPC overhead, simplifies deployment, enables mixed in-process + external server configs. Pattern: define tools as decorated async functions, bundle into create_sdk_mcp_server(), pass to ClaudeAgentOptions.mcp_servers. This is the direction MCP tooling is heading — in-process over subprocess.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:36:05.034Z",
      "tags": [
        "mcp",
        "sdk",
        "python",
        "tooling",
        "claude-agent"
      ],
      "lastValidated": "2026-02-01T01:36:05.034Z"
    },
    {
      "id": "p010",
      "source": "github.com/anthropics/claude-code-sdk-python",
      "category": "tooling",
      "title": "SDK hooks for deterministic control flow",
      "description": "Claude Agent SDK hooks (PreToolUse, PostToolUse, PostToolUseFailure, UserPromptSubmit) let you inject deterministic Python callbacks into the agent loop. Use cases: block dangerous commands, validate tool inputs, add logging/metrics, enforce policies. Hooks receive typed inputs and can return approve/deny/modify decisions. Key insight: hooks run in the application, not in Claude — they're guardrails, not prompts.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:36:09.145Z",
      "tags": [
        "hooks",
        "sdk",
        "guardrails",
        "safety",
        "claude-agent"
      ],
      "lastValidated": "2026-02-01T01:36:09.145Z"
    },
    {
      "id": "p011",
      "source": "github.com/anthropics/claude-code-sdk-python",
      "category": "architecture",
      "title": "Session forking for exploration branches",
      "description": "Claude Agent SDK supports fork_session option — resume a conversation from a checkpoint and branch into different approaches. Combined with file checkpointing (enable_file_checkpointing + rewind_files()), enables speculative execution: try approach A, rewind files, try approach B, compare results. Useful for agents that need to evaluate multiple strategies.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:36:12.469Z",
      "tags": [
        "sdk",
        "sessions",
        "branching",
        "speculative-execution"
      ],
      "lastValidated": "2026-02-01T01:36:12.469Z"
    },
    {
      "id": "p012",
      "source": "github.com/modelcontextprotocol/servers",
      "category": "ecosystem",
      "title": "MCP Server Registry replaces awesome-lists",
      "description": "MCP servers are now published to a centralized registry at registry.modelcontextprotocol.io instead of README lists. The official servers repo only keeps reference implementations (everything, memory, filesystem, sequential-thinking). Community servers go to github.com/modelcontextprotocol/registry. This is the canonical discovery mechanism for MCP servers now.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:36:24.999Z",
      "tags": [
        "mcp",
        "registry",
        "ecosystem",
        "discovery"
      ],
      "lastValidated": "2026-02-01T01:36:24.999Z"
    },
    {
      "id": "p013",
      "source": "github.com/anthropics/claude-code",
      "category": "prompting",
      "title": "Slash commands via .claude/commands/ markdown files",
      "description": "Claude Code uses .claude/commands/*.md files as reusable prompt templates with YAML frontmatter for allowed-tools and descriptions. Each file becomes a slash command. Frontmatter scopes tool permissions per command (e.g. only git/gh for commit workflows). Commands can interpolate live context using !`shell command` syntax. This pattern enables composable, permission-scoped agent workflows stored as version-controlled markdown.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:56:41.755Z",
      "tags": [
        "claude-code",
        "commands",
        "prompt-templates",
        "permission-scoping"
      ],
      "lastValidated": "2026-02-01T01:56:41.755Z"
    },
    {
      "id": "p014",
      "source": "github.com/anthropics/claude-code",
      "category": "architecture",
      "title": "Parallel agent fan-out for search tasks",
      "description": "The dedupe command launches 5 parallel agents with diverse search strategies, then feeds results into a filtering agent. Pattern: (1) single agent to summarize/understand, (2) N parallel agents with diverse approaches, (3) single agent to filter/merge. Effective for search-heavy tasks where recall matters more than precision initially.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:56:45.357Z",
      "tags": [
        "agent-orchestration",
        "parallel",
        "fan-out",
        "search"
      ],
      "lastValidated": "2026-02-01T01:56:45.357Z"
    },
    {
      "id": "p016",
      "source": "github.com/anthropics/anthropic-cookbook",
      "category": "tooling",
      "title": "CLAUDE.md as project context file",
      "description": "A CLAUDE.md file at repo root gives Claude Code project-specific context: quick start commands, code style rules, git workflow conventions, project structure. Acts as a machine-readable onboarding doc that both humans and AI can use.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:58:40.473Z",
      "tags": [
        "claude-code",
        "project-config",
        "onboarding"
      ],
      "lastValidated": "2026-02-01T01:58:40.473Z"
    },
    {
      "id": "p017",
      "source": "github.com/anthropics/anthropic-cookbook",
      "category": "tooling",
      "title": "Tool-scoped slash commands for safety",
      "description": "Slash command YAML frontmatter can restrict allowed-tools to a whitelist (e.g., only Bash(gh pr comment:*), Read, Glob). This prevents commands from accidentally executing dangerous operations while still being useful for their specific purpose.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T01:58:43.753Z",
      "tags": [
        "security",
        "claude-code",
        "guardrails"
      ],
      "lastValidated": "2026-02-01T01:58:43.753Z"
    },
    {
      "id": "p018",
      "source": "github.com/anthropics/claude-code-action",
      "category": "architecture",
      "title": "Mode registry pattern for multi-trigger GitHub Actions",
      "description": "Claude Code Action uses a Mode interface with shouldTrigger() and prepare() methods, registered in a central registry. Each mode (tag, agent) handles different GitHub event types. The registry validates mode compatibility with event types and selects the right one automatically. This is a clean pattern for any system that needs to respond differently to different trigger types — extensible without modifying core logic.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:28:41.616Z",
      "tags": [
        "github-actions",
        "extensibility",
        "registry-pattern",
        "event-driven"
      ],
      "lastValidated": "2026-02-01T02:28:41.616Z"
    },
    {
      "id": "p020",
      "source": "github.com/anthropics/claude-code-action",
      "category": "architecture",
      "title": "Parallel subagent code review with role specialization",
      "description": "The review-pr command spawns 5 parallel subagents (code-quality, performance, test-coverage, documentation-accuracy, security), each instructed to only surface noteworthy feedback. A coordinating agent then filters their combined output, posting only what it also deems noteworthy. This two-pass filter (specialist generates, coordinator curates) reduces noise significantly. Applicable to any multi-agent review or analysis pipeline.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:28:51.129Z",
      "tags": [
        "multi-agent",
        "code-review",
        "parallel-execution",
        "noise-reduction"
      ],
      "lastValidated": "2026-02-01T02:28:51.129Z"
    },
    {
      "id": "p021",
      "source": "github.com/modelcontextprotocol/python-sdk",
      "category": "reliability",
      "title": "100% test coverage with strict exception handling rules",
      "description": "MCP Python SDK enforces 100% test coverage (fail_under=100 in coverage config) combined with strict exception handling: always logger.exception() over logger.error(), catch specific exceptions (OSError, JSONDecodeError, ConnectionError), and FORBIDDEN bare \"except Exception:\" except in top-level handlers. The combination of full coverage + specific exception catching produces highly reliable code. The CLAUDE.md explicitly lists which exception types to use for which operations.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:28:55.624Z",
      "tags": [
        "testing",
        "error-handling",
        "code-quality",
        "python"
      ],
      "lastValidated": "2026-02-01T02:28:55.624Z"
    },
    {
      "id": "p022",
      "source": "github.com/jlowin/fastmcp",
      "category": "tooling",
      "title": "File size enforcement via loq ratchet",
      "description": "FastMCP uses loq (github.com/jlowin/loq) to enforce maximum file sizes as a pre-commit check. loq.toml sets limits; `loq baseline` ratchets them down. Prevents files from growing unbounded — a common problem in long-lived projects. Simple, deterministic guardrail that doesn't require human judgment. Adoptable pattern: add file size limits to any project with a pre-commit hook.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:49:30.647Z",
      "tags": [
        "code-quality",
        "pre-commit",
        "file-size",
        "guardrails"
      ],
      "lastValidated": "2026-02-01T02:49:30.647Z"
    },
    {
      "id": "p023",
      "source": "github.com/jlowin/fastmcp",
      "category": "architecture",
      "title": "Three-abstraction MCP design: Components, Providers, Transforms",
      "description": "FastMCP structures MCP servers around three composable abstractions: Components (what you expose: tools, resources, prompts), Providers (where components come from: functions, files, OpenAPI specs, remote servers), and Transforms (how clients see them: namespacing, filtering, auth, versioning). Same server can present differently to different clients. This separation of concerns makes complex MCP setups manageable. Relevant for our own MCP server — we currently mix all three concerns in index.js.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:49:35.049Z",
      "tags": [
        "mcp",
        "architecture",
        "separation-of-concerns",
        "fastmcp"
      ],
      "lastValidated": "2026-02-01T02:49:35.049Z"
    },
    {
      "id": "p024",
      "source": "github.com/jlowin/fastmcp",
      "category": "prompting",
      "title": "AGENTS.md as multi-audience dev guide",
      "description": "FastMCP maintains AGENTS.md (identical to CLAUDE.md) as development guidelines targeting both LLM agents and human developers. Includes: required workflow commands, repo structure table, git rules, commit conventions, code standards, module export policy, and documentation principles. Key insight: agent attribution requirement — external agents must identify themselves in commits. Also: 'a feature doesn't exist unless documented' as an enforced principle. The dual-file approach (AGENTS.md + CLAUDE.md) ensures multiple agent tools find the guidelines.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T02:49:40.569Z",
      "tags": [
        "developer-experience",
        "agent-guidelines",
        "documentation",
        "claude-code"
      ],
      "lastValidated": "2026-02-01T02:49:40.569Z"
    },
    {
      "id": "p025",
      "source": "github.com/modelcontextprotocol/inspector",
      "category": "tooling",
      "title": "Dual-mode tools: UI + CLI from same codebase",
      "description": "MCP Inspector ships both a web UI (React) and a CLI mode from the same monorepo. CLI mode enables scripting, CI/CD integration, and AI coding assistant feedback loops — same tool capabilities, different interface. Pattern: build the core logic once, expose via both interactive UI and scriptable CLI. Useful for developer tools that need both exploration (UI) and automation (CLI).",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:13:51.113Z",
      "tags": [
        "mcp",
        "cli",
        "developer-tools",
        "automation"
      ],
      "lastValidated": "2026-02-01T03:13:51.113Z"
    },
    {
      "id": "p026",
      "source": "github.com/modelcontextprotocol/inspector",
      "category": "architecture",
      "title": "Protocol bridge proxy for transport abstraction",
      "description": "MCP Inspector's proxy server acts as both an MCP client (connecting to servers via stdio/SSE/streamable-http) and an HTTP server (serving the web UI). This bridge pattern decouples the UI from transport details — the browser always speaks HTTP while the proxy handles protocol translation. Useful when building tools that need to work with multiple transport mechanisms without duplicating client logic.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:13:54.698Z",
      "tags": [
        "mcp",
        "proxy",
        "transport",
        "architecture"
      ],
      "lastValidated": "2026-02-01T03:13:54.698Z"
    },
    {
      "id": "p027",
      "source": "github.com/microsoft/autogen",
      "category": "architecture",
      "title": "Agent-as-Tool for hierarchical multi-agent orchestration",
      "description": "AutoGen's AgentTool wraps an entire agent as a callable tool, enabling a parent agent to delegate to specialist sub-agents via standard tool-calling. This creates composable hierarchies: a general agent routes to math_expert, chemistry_expert, etc. without custom orchestration code. The pattern collapses multi-agent coordination into the existing tool-call interface that LLMs already understand. Applicable to any framework where agents need to delegate to specialists.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T03:13:59.025Z",
      "tags": [
        "multi-agent",
        "orchestration",
        "tool-calling",
        "composition"
      ],
      "lastValidated": "2026-02-01T03:13:59.025Z"
    },
    {
      "id": "p028",
      "source": "github.com/anthropics/claude-code v2.1.19-2.1.29",
      "category": "tooling",
      "title": "Granular permission layering: content-level ask overrides tool-level allow",
      "description": "Claude Code v2.1.27 introduced permission layering where content-level 'ask' takes precedence over tool-level 'allow'. Example: allow: [\"Bash\"], ask: [\"Bash(rm *)\"] now prompts for confirmation on destructive commands even though Bash is broadly allowed. This enables a default-allow-with-exceptions pattern — more ergonomic than whitelisting every safe command. Useful for autonomous agents that need broad tool access but want guardrails on specific dangerous operations.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T04:23:58.103Z",
      "tags": [
        "claude-code",
        "permissions",
        "guardrails",
        "security"
      ],
      "lastValidated": "2026-02-01T04:23:58.103Z"
    },
    {
      "id": "p029",
      "source": "github.com/anthropics/claude-code v2.1.19",
      "category": "tooling",
      "title": "Task dependency tracking for multi-step agent workflows",
      "description": "Claude Code v2.1.19 added a task management system with dependency tracking (CLAUDE_CODE_ENABLE_TASKS env var). Tasks can declare dependencies on other tasks, enabling DAG-style workflow execution. Combined with TaskUpdate for deletion and the existing TodoWrite, this creates a structured execution planner inside the agent loop. Relevant for build sessions that need to sequence work items with prerequisites.",
      "confidence": "observed",
      "extractedAt": "2026-02-01T04:24:01.556Z",
      "tags": [
        "claude-code",
        "task-management",
        "workflow",
        "dependencies"
      ],
      "lastValidated": "2026-02-01T04:24:01.556Z"
    },
    {
      "id": "p028",
      "source": "self:session-292",
      "category": "architecture",
      "title": "Agent Identity Protocol via Ed25519 Signed Manifests",
      "description": "Agents serve /.well-known/agent.json with Ed25519 public key and signed proofs linking their handles across platforms. Each proof contains a JSON message (claim type, platform, handle, agent, timestamp) and its Ed25519 signature. Verification: fetch manifest, reconstruct SPKI DER from raw pubkey, verify each proof signature. Supports key rotation via revoked[] array. No blockchain needed — DNS as trust root.",
      "confidence": "verified",
      "extractedAt": "2026-02-01T07:19:36.269Z",
      "tags": [
        "identity",
        "ed25519",
        "verification",
        "cross-platform",
        "agent-protocol"
      ],
      "validators": []
    }
  ]
}